#pragma once

#include <Scheduler/Job.hpp>

namespace xrn::scheduler {

///////////////////////////////////////////////////////////////////////////
/// \brief Contains a thread that can run things
///
/// \include Runner.hpp <Runner.hpp>
///
///////////////////////////////////////////////////////////////////////////
class Runner {

public:

    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Constructors
    //
    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Default constructor
    ///
    ///////////////////////////////////////////////////////////////////////////
    explicit Runner() = default;



    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Rule of 5
    //
    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Destructor
    ///
    ///////////////////////////////////////////////////////////////////////////
    ~Runner() = default;

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Copy constructor
    ///
    ///////////////////////////////////////////////////////////////////////////
    Runner(
        const Runner& other
    ) noexcept = delete;

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Copy assign operator
    ///
    ///////////////////////////////////////////////////////////////////////////
    auto operator=(
        const Runner& other
    ) noexcept
        -> Runner& = delete;

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Move constructor
    ///
    ///////////////////////////////////////////////////////////////////////////
    Runner(
        Runner&& other
    ) noexcept;

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Move assign operator
    ///
    ///////////////////////////////////////////////////////////////////////////
    auto operator=(
        Runner&& other
    ) noexcept
        -> Runner&;



    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Runner
    //
    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Emplace a function in the pool
    ///
    /// The function will be executed with the configuration provided
    ///
    ///////////////////////////////////////////////////////////////////////////
    void runner()
    {
        while (true) {
            std::unique_lock lock{ m_mutex };
            if (!m_pJob) {
                if (m_exitWhenDone) {
                    break;
                }
                m_cv.wait(lock, [this]{ return m_pJob || m_exitWhenDone; });
            }
            m_pJob->run();
            m_pJob.reset();
        }
    }

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Starts the runner
    ///
    ///////////////////////////////////////////////////////////////////////////
    void start()
    {
        m_runner = ::std::thread{ &Runner::runner, this };
    }

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Adds a function to the queue
    ///
    ///////////////////////////////////////////////////////////////////////////
    void push(
        ::std::shared_ptr<::xrn::scheduler::Job> pJob
    )
    {
        m_pJob = pJob;
    }

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Adds a function to the queue
    ///
    ///////////////////////////////////////////////////////////////////////////
    [[ nodiscard ]] auto isJobCompleted()
        -> bool
    {
        return !m_pJob;
    }

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Will exit when done with all jobs
    ///
    ///////////////////////////////////////////////////////////////////////////
    void exitWhenDone()
    {
        m_exitWhenDone = true;
        m_cv.notify_one();
    }

    ///////////////////////////////////////////////////////////////////////////
    /// \brief joins the thread
    ///
    ///////////////////////////////////////////////////////////////////////////
    void join()
    {
        if (m_runner.joinable()) {
            m_runner.join();
        }
    }



private:

    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Member variables
    //
    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////

    static inline ::std::atomic<::std::uint8_t> idGiver{ 0 };
    ::std::uint8_t m_id{ idGiver++ };

    ::std::thread m_runner;
    ::std::mutex m_mutex;
    ::std::condition_variable m_cv;

    ::std::atomic<bool> m_exitWhenDone{ false };

    ::std::shared_ptr<::xrn::scheduler::Job> m_pJob;

};

} // namespace xrn::scheduler
