#pragma once

#include <Scheduler/Runner.hpp>

namespace xrn::scheduler {

///////////////////////////////////////////////////////////////////////////
/// \brief Runs function in parallel
///
/// \include Scheduler.hpp <Scheduler.hpp>
///
///////////////////////////////////////////////////////////////////////////
class Scheduler {

public:

    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Constructors
    //
    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Default constructor
    ///
    ///////////////////////////////////////////////////////////////////////////
    explicit Scheduler(
        ::std::uint8_t numberOfThreads = 8
    )
        : m_runners{ numberOfThreads }
    {}



    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Rule of 5
    //
    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Destructor
    ///
    ///////////////////////////////////////////////////////////////////////////
    ~Scheduler()
    {
        this->stop();
    }

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Copy constructor
    ///
    ///////////////////////////////////////////////////////////////////////////
    Scheduler(
        const Scheduler& other
    ) noexcept = delete;

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Copy assign operator
    ///
    ///////////////////////////////////////////////////////////////////////////
    auto operator=(
        const Scheduler& other
    ) noexcept
        -> Scheduler& = delete;

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Move constructor
    ///
    ///////////////////////////////////////////////////////////////////////////
    Scheduler(
        Scheduler&& other
    ) noexcept = default;

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Move assign operator
    ///
    ///////////////////////////////////////////////////////////////////////////
    auto operator=(
        Scheduler&& other
    ) noexcept
        -> Scheduler& = default;



    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Function managment
    //
    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////

    ///////////////////////////////////////////////////////////////////////////
    ///
    ///////////////////////////////////////////////////////////////////////////
    void scheduler()
    {
    }


    ///////////////////////////////////////////////////////////////////////////
    /// \brief Emplace a function in the pool
    ///
    /// The function will be executed with the configuration provided
    ///
    ///////////////////////////////////////////////////////////////////////////
    template <
        typename LambdaType
    > void push(
        LambdaType&& lambda,
        ::xrn::scheduler::Job::Configuration config
    )
    {
        m_pJobs.emplace_back(::std::make_shared<::xrn::scheduler::UnderlyingJob<LambdaType>>(
            lambda, ::std::move(config)
        ));
    }

    ///////////////////////////////////////////////////////////////////////////
    ///
    ///////////////////////////////////////////////////////////////////////////
    void start()
    {
        for (auto& runner : m_runners) {
            runner.start();
        }
        m_scheduler = ::std::thread{ &Scheduler::scheduler, this };
    }

    ///////////////////////////////////////////////////////////////////////////
    ///
    ///////////////////////////////////////////////////////////////////////////
    void stop()
    {
        for (auto& runner : m_runners) {
            runner.join();
        }
        if (m_scheduler.joinable()) {
            m_scheduler.join();
        }
    }

    ///////////////////////////////////////////////////////////////////////////
    ///
    ///////////////////////////////////////////////////////////////////////////
    void join()
    {
        for (auto& runner : m_runners) {
            runner.exitWhenDone();
        }
        for (auto& runner : m_runners) {
            runner.join();
        }
        if (m_scheduler.joinable()) {
            m_scheduler.join();
        }
    }



private:

    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Member variables
    //
    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////

    ::std::thread m_scheduler;

    ::std::vector<::xrn::scheduler::Runner> m_runners;
    ::std::vector<::std::shared_ptr<::xrn::scheduler::Job>> m_pJobs;

    ::std::atomic<bool> m_isRunning{ true };

};

} // namespace xrn::scheduler
